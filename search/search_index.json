{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 What is Decompose? \u00b6 Decompose is a Kotlin Multiplatform lifecycle-aware business logic components (aka BLoCs) with routing functionality and pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React, etc.) This project is inspired by Badoos RIBs fork of the Uber RIBs framework. Supported targets \u00b6 android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64 Why Decompose? \u00b6 Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-decompose","text":"Decompose is a Kotlin Multiplatform lifecycle-aware business logic components (aka BLoCs) with routing functionality and pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React, etc.) This project is inspired by Badoos RIBs fork of the Uber RIBs framework.","title":"What is Decompose?"},{"location":"#supported-targets","text":"android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64","title":"Supported targets"},{"location":"#why-decompose","text":"Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Why Decompose?"},{"location":"component/back-button/","text":"Back button handling \u00b6 Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app. Navigation with back button \u00b6 The Router can automatically navigate back when the back button is pressed. All you need to do is to supply the handleBackButton=true argument when you create the Router . Please see the related documentation page for more information. Manual back button handling \u00b6 The back button can be handled manually using BackPressedHandler (comes from Essenty library), which is provided by ComponentContext . The decompose module adds Essenty's back-pressed module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the BackPressedDispatcher . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { backPressedHandler . register ( :: onBackPressed ) } private fun onBackPressed (): Boolean { // Handle the back button. // Return true to consume the event, or false to allow other consumers. return false } }","title":"Back button"},{"location":"component/back-button/#back-button-handling","text":"Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app.","title":"Back button handling"},{"location":"component/back-button/#navigation-with-back-button","text":"The Router can automatically navigate back when the back button is pressed. All you need to do is to supply the handleBackButton=true argument when you create the Router . Please see the related documentation page for more information.","title":"Navigation with back button"},{"location":"component/back-button/#manual-back-button-handling","text":"The back button can be handled manually using BackPressedHandler (comes from Essenty library), which is provided by ComponentContext . The decompose module adds Essenty's back-pressed module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the BackPressedDispatcher .","title":"Manual back button handling"},{"location":"component/back-button/#usage-example","text":"import com.arkivanov.decompose.ComponentContext class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { backPressedHandler . register ( :: onBackPressed ) } private fun onBackPressed (): Boolean { // Handle the back button. // Return true to consume the event, or false to allow other consumers. return false } }","title":"Usage example"},{"location":"component/custom-component-context/","text":"Custom ComponentContext \u00b6 If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice. Create and implement custom ComponentContext \u00b6 For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here } How to create router with custom ComponentContext \u00b6 In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialConfiguration : () -> C , initialBackStack : () -> List < C > = :: emptyList , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialConfiguration = initialConfiguration , initialBackStack = initialBackStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialConfiguration = { Configuration . Home }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#custom-componentcontext","text":"If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice.","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#create-and-implement-custom-componentcontext","text":"For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here }","title":"Create and implement custom ComponentContext"},{"location":"component/custom-component-context/#how-to-create-router-with-custom-componentcontext","text":"In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialConfiguration : () -> C , initialBackStack : () -> List < C > = :: emptyList , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialConfiguration = initialConfiguration , initialBackStack = initialBackStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialConfiguration = { Configuration . Home }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"How to create router with custom ComponentContext"},{"location":"component/instance-retaining/","text":"Instance retaining \u00b6 Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. This commonly used in Android when configuration changes occur. The ComponentContext interface extends the InstanceKeeperOwner interface, which provides the InstanceKeeper - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author). The decompose module adds Essenty's instance-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the InstanceKeeper . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.instancekeeper.InstanceKeeper import com.arkivanov.essenty.instancekeeper.getOrCreate class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val someLogic = instanceKeeper . getOrCreate ( :: SomeLogic ) /* * Instances of this class will be retained. * \u26a0\ufe0f Pay attention to not leak any dependencies. */ private class SomeLogic : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"Instance retaining"},{"location":"component/instance-retaining/#instance-retaining","text":"Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. This commonly used in Android when configuration changes occur. The ComponentContext interface extends the InstanceKeeperOwner interface, which provides the InstanceKeeper - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author). The decompose module adds Essenty's instance-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the InstanceKeeper .","title":"Instance retaining"},{"location":"component/instance-retaining/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.instancekeeper.InstanceKeeper import com.arkivanov.essenty.instancekeeper.getOrCreate class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val someLogic = instanceKeeper . getOrCreate ( :: SomeLogic ) /* * Instances of this class will be retained. * \u26a0\ufe0f Pay attention to not leak any dependencies. */ private class SomeLogic : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"Usage example"},{"location":"component/lifecycle/","text":"Lifecycle \u00b6 The component lifecycle is very similar to the Android Activity lifecycle . The ComponentContext interface extends the LifecycleOwner interface, which provides the Lifecycle - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author). The decompose module adds Essenty's lifecycle module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the Lifecycle . Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle. Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.lifecycle.Lifecycle import com.arkivanov.essenty.lifecycle.doOnCreate import com.arkivanov.essenty.lifecycle.subscribe class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { lifecycle . subscribe ( object : Lifecycle . Callbacks { override fun onCreate () { /* Component created */ } // onStart, onResume, onPause, onStop, onDestroy } ) lifecycle . subscribe ( onCreate = { /* Component created */ }, // onStart, onResume, onPause, onStop, onDestroy ) lifecycle . doOnCreate { /* Component created */ } // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy } }","title":"Lifecycle"},{"location":"component/lifecycle/#lifecycle","text":"The component lifecycle is very similar to the Android Activity lifecycle . The ComponentContext interface extends the LifecycleOwner interface, which provides the Lifecycle - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author). The decompose module adds Essenty's lifecycle module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the Lifecycle . Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle.","title":"Lifecycle"},{"location":"component/lifecycle/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.lifecycle.Lifecycle import com.arkivanov.essenty.lifecycle.doOnCreate import com.arkivanov.essenty.lifecycle.subscribe class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { lifecycle . subscribe ( object : Lifecycle . Callbacks { override fun onCreate () { /* Component created */ } // onStart, onResume, onPause, onStop, onDestroy } ) lifecycle . subscribe ( onCreate = { /* Component created */ }, // onStart, onResume, onPause, onStop, onDestroy ) lifecycle . doOnCreate { /* Component created */ } // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy } }","title":"Usage example"},{"location":"component/overview/","text":"Component Overview \u00b6 A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information. UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components. Component hierarchy \u00b6 Pluggable UI hierarchy \u00b6 Typical component structure \u00b6 ComponentContext \u00b6 Each component has an associated ComponentContext which implements the following interfaces: LifecycleOwner , provided by Essenty library, so each component has its own lifecycle StateKeeperOwner , provided by Essenty library, so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels) BackPressedDispatcherOwner , provided by Essenty library, so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code } When instantiating a root component we have to create ComponentContext manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext . There are also handy helper functions provided by Jetpack/JetBrains Compose extension modules. Child components \u00b6 Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Manually - prefer this option if you need to add a permanent child component, or to manually control its Lifecycle . Adding a child component manually \u00b6 In order to add a child component manually, you need to create a separate child ComponentContext for it. There is ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null) extension function provided by the library, which creates a new instance of ComponentContext and attaches it to the parent one. This function has two arguments: key - A key of the child ComponentContext , must be unique within the parent ComponentContext lifecycle - An optional Lifecycle of the child ComponentContext , can be used if the child component needs to be destroyed earlier, or if you need manual control. If supplied, then the following conditions apply: the resulting Lifecycle of the child component will honour both the parent Lifecycle and the supplied one when the supplied Lifecycle is explicitly destroyed, the child ComponentContext detaches from its parent Here is an example of creating a permanent child component: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter : Counter = Counter ( childContext ( key = \"Counter\" )) } Here is an example of creating a child component with manual lifecycle: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var counterHolder : CounterHolder? = null fun createCounter () { val lifecycle = LifecycleRegistry () val counter = Counter ( childContext ( key = \"Counter\" , lifecycle = lifecycle )) lifecycle . resume () counterHolder = CounterHolder ( counter , lifecycle ) } fun destroyCounter () { counterHolder ?. lifecycle ?. destroy () counterHolder = null } private class CounterHolder ( val counter : Counter , val lifecycle : LifecycleRegistry , ) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function. Examples \u00b6 Simplest Component Example \u00b6 Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) } Jetpack/JetBrains Compose UI Example \u00b6 @Composable fun CounterUi ( counter : Counter ) { val state by counter . state . subscribeAsState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } Value - is a multiplatform way to expose streams of states. It contains the value property, which always returns the current state. It also provides ability to observe state changes via subscribe / unsubscribe methods. There is MutableValue which is a mutable variant of Value . If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose. You can convert between State and Value using one of the Compose extension modules . SwiftUI Example \u00b6 struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } }","title":"Overview"},{"location":"component/overview/#component-overview","text":"A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information. UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components.","title":"Component Overview"},{"location":"component/overview/#component-hierarchy","text":"","title":"Component hierarchy"},{"location":"component/overview/#pluggable-ui-hierarchy","text":"","title":"Pluggable UI hierarchy"},{"location":"component/overview/#typical-component-structure","text":"","title":"Typical component structure"},{"location":"component/overview/#componentcontext","text":"Each component has an associated ComponentContext which implements the following interfaces: LifecycleOwner , provided by Essenty library, so each component has its own lifecycle StateKeeperOwner , provided by Essenty library, so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels) BackPressedDispatcherOwner , provided by Essenty library, so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code } When instantiating a root component we have to create ComponentContext manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext . There are also handy helper functions provided by Jetpack/JetBrains Compose extension modules.","title":"ComponentContext"},{"location":"component/overview/#child-components","text":"Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Manually - prefer this option if you need to add a permanent child component, or to manually control its Lifecycle .","title":"Child components"},{"location":"component/overview/#adding-a-child-component-manually","text":"In order to add a child component manually, you need to create a separate child ComponentContext for it. There is ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null) extension function provided by the library, which creates a new instance of ComponentContext and attaches it to the parent one. This function has two arguments: key - A key of the child ComponentContext , must be unique within the parent ComponentContext lifecycle - An optional Lifecycle of the child ComponentContext , can be used if the child component needs to be destroyed earlier, or if you need manual control. If supplied, then the following conditions apply: the resulting Lifecycle of the child component will honour both the parent Lifecycle and the supplied one when the supplied Lifecycle is explicitly destroyed, the child ComponentContext detaches from its parent Here is an example of creating a permanent child component: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter : Counter = Counter ( childContext ( key = \"Counter\" )) } Here is an example of creating a child component with manual lifecycle: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var counterHolder : CounterHolder? = null fun createCounter () { val lifecycle = LifecycleRegistry () val counter = Counter ( childContext ( key = \"Counter\" , lifecycle = lifecycle )) lifecycle . resume () counterHolder = CounterHolder ( counter , lifecycle ) } fun destroyCounter () { counterHolder ?. lifecycle ?. destroy () counterHolder = null } private class CounterHolder ( val counter : Counter , val lifecycle : LifecycleRegistry , ) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function.","title":"Adding a child component manually"},{"location":"component/overview/#examples","text":"","title":"Examples"},{"location":"component/overview/#simplest-component-example","text":"Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) }","title":"Simplest Component Example"},{"location":"component/overview/#jetpackjetbrains-compose-ui-example","text":"@Composable fun CounterUi ( counter : Counter ) { val state by counter . state . subscribeAsState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } Value - is a multiplatform way to expose streams of states. It contains the value property, which always returns the current state. It also provides ability to observe state changes via subscribe / unsubscribe methods. There is MutableValue which is a mutable variant of Value . If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose. You can convert between State and Value using one of the Compose extension modules .","title":"Jetpack/JetBrains Compose UI Example"},{"location":"component/overview/#swiftui-example","text":"struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } }","title":"SwiftUI Example"},{"location":"component/state-preservation/","text":"State preservation \u00b6 Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. A very common use case is Android Activity recreation due to configuration changes, or process death. The ComponentContext interface extends the StateKeeperOwner interface, which provides the StateKeeper - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author). The decompose module adds Essenty's state-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the StateKeeper . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.parcelable.Parcelable import com.arkivanov.essenty.parcelable.Parcelize import com.arkivanov.essenty.statekeeper.consume class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state : State = stateKeeper . consume ( key = \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( key = \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"State preservation"},{"location":"component/state-preservation/#state-preservation","text":"Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. A very common use case is Android Activity recreation due to configuration changes, or process death. The ComponentContext interface extends the StateKeeperOwner interface, which provides the StateKeeper - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author). The decompose module adds Essenty's state-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the StateKeeper .","title":"State preservation"},{"location":"component/state-preservation/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.parcelable.Parcelable import com.arkivanov.essenty.parcelable.Parcelize import com.arkivanov.essenty.statekeeper.consume class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state : State = stateKeeper . consume ( key = \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( key = \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"Usage example"},{"location":"extensions/android/","text":"Extensions for Android views \u00b6 Experimental extensions and utilities for easier integration of Decompose with Android views. Setup \u00b6 Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" ) Content \u00b6 Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience. ViewContext \u00b6 As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own Lifecycle . The idea is to supply every view sub-tree with ViewContext , which exposes the following properties: parent - a ViewGroup where the view sub-tree should be inflated lifecycle - a Lifecycle of the view sub-tree The following ViewContext extensions are available: val ViewContext.context: Context - returns the Android Context of the view sub-tree val ViewContext.resources: Resources - returns the Android Resources of the view sub-tree val ViewContext.layoutInflater: LayoutInflater - returns the Android LayoutInflater fun ViewContext.child(ViewGroup, inflater): ViewContext - creates a child ViewContext with another parent ViewGroup , which shares the Lifecycle of the parent ViewContext . The inflater arguments should inflate a sub-tree of views, but without adding it to the parent . DefaultViewContext - is a default implementation of ViewContext , which can be used to manually create new instances when needed. RouterView \u00b6 RouterView is an Android ViewGroup which observes the Router and manages child views. Once RouterView is added to the view hierarchy, just call its children(...) method with the following arguments: routerState - the observable Value of RouterState , typically the Router.state property lifecycle - the lifecycle of the RouterView or its closest parent replaceChildView - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied Examples \u00b6 You can find an example of using this extensions module in the Counter sample. Initializing the root in Activity : override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val root = CounterRootComponent ( defaultComponentContext ()) val viewContext = DefaultViewContext ( parent = findViewById ( R . id . content ), lifecycle = essentyLifecycle () ) viewContext . apply { child ( parent ) { CounterRootView ( root ) } } } A simple child view: fun ViewContext . CounterView ( counter : Counter ): View { // Inflate the layout without adding it to the parent val layout = layoutInflater . inflate ( R . layout . counter , parent , false ) // Find required views val counterText : TextView = layout . findViewById ( R . id . text_count ) // Observe Counter models and update the view counter . model . observe ( lifecycle ) { data -> counterText . text = data . text } return layout // Return the root of the inflated sub-tree } RouterView example: fun ViewContext . CounterRootView ( counterRoot : CounterRoot ): View { val layout = layoutInflater . inflate ( R . layout . counter_root , parent , false ) val nextButton : View = layout . findViewById ( R . id . button_next ) val router : RouterView = layout . findViewById ( R . id . router ) nextButton . setOnClickListener { counterRoot . onNextChild () } // Create a child `ViewContext` for the inner `CounterView` child ( layout . findViewById ( R . id . container_counter )) { // Reuse the `CounterView` CounterView ( counterRoot . counter ) } // Subscribe the `RouterView` to the `Router` router . children ( counterRoot . routerState , lifecycle ) { parent , child , _ -> // Remove all existing views parent . removeAllViews () // Add the child view for the currently active child component parent . addView ( CounterInnerView ( child . inner )) } return layout }","title":"Extensions for Android views"},{"location":"extensions/android/#extensions-for-android-views","text":"Experimental extensions and utilities for easier integration of Decompose with Android views.","title":"Extensions for Android views"},{"location":"extensions/android/#setup","text":"Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Setup"},{"location":"extensions/android/#content","text":"Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience.","title":"Content"},{"location":"extensions/android/#viewcontext","text":"As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own Lifecycle . The idea is to supply every view sub-tree with ViewContext , which exposes the following properties: parent - a ViewGroup where the view sub-tree should be inflated lifecycle - a Lifecycle of the view sub-tree The following ViewContext extensions are available: val ViewContext.context: Context - returns the Android Context of the view sub-tree val ViewContext.resources: Resources - returns the Android Resources of the view sub-tree val ViewContext.layoutInflater: LayoutInflater - returns the Android LayoutInflater fun ViewContext.child(ViewGroup, inflater): ViewContext - creates a child ViewContext with another parent ViewGroup , which shares the Lifecycle of the parent ViewContext . The inflater arguments should inflate a sub-tree of views, but without adding it to the parent . DefaultViewContext - is a default implementation of ViewContext , which can be used to manually create new instances when needed.","title":"ViewContext"},{"location":"extensions/android/#routerview","text":"RouterView is an Android ViewGroup which observes the Router and manages child views. Once RouterView is added to the view hierarchy, just call its children(...) method with the following arguments: routerState - the observable Value of RouterState , typically the Router.state property lifecycle - the lifecycle of the RouterView or its closest parent replaceChildView - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied","title":"RouterView"},{"location":"extensions/android/#examples","text":"You can find an example of using this extensions module in the Counter sample. Initializing the root in Activity : override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val root = CounterRootComponent ( defaultComponentContext ()) val viewContext = DefaultViewContext ( parent = findViewById ( R . id . content ), lifecycle = essentyLifecycle () ) viewContext . apply { child ( parent ) { CounterRootView ( root ) } } } A simple child view: fun ViewContext . CounterView ( counter : Counter ): View { // Inflate the layout without adding it to the parent val layout = layoutInflater . inflate ( R . layout . counter , parent , false ) // Find required views val counterText : TextView = layout . findViewById ( R . id . text_count ) // Observe Counter models and update the view counter . model . observe ( lifecycle ) { data -> counterText . text = data . text } return layout // Return the root of the inflated sub-tree } RouterView example: fun ViewContext . CounterRootView ( counterRoot : CounterRoot ): View { val layout = layoutInflater . inflate ( R . layout . counter_root , parent , false ) val nextButton : View = layout . findViewById ( R . id . button_next ) val router : RouterView = layout . findViewById ( R . id . router ) nextButton . setOnClickListener { counterRoot . onNextChild () } // Create a child `ViewContext` for the inner `CounterView` child ( layout . findViewById ( R . id . container_counter )) { // Reuse the `CounterView` CounterView ( counterRoot . counter ) } // Subscribe the `RouterView` to the `Router` router . children ( counterRoot . routerState , lifecycle ) { parent , child , _ -> // Remove all existing views parent . removeAllViews () // Add the child view for the currently active child component parent . addView ( CounterInnerView ( child . inner )) } return layout }","title":"Examples"},{"location":"extensions/compose/","text":"Extensions for Jetpack/JetBrains Compose \u00b6 Extensions and utilities for easier integration of Decompose with Jetpack/JetBrains Compose. Setup \u00b6 Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant. Setup extensions for Jetpack Compose \u00b6 Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) Setup extensions for JetBrains Compose \u00b6 Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" ) Content \u00b6 As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module. Converting Value to State \u00b6 To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeUi ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () } Navigating between Composable components \u00b6 The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided. Here is an example of switching child components on navigation: // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Profile ( val component : ProfileComponent ) : Child () data class Settings ( val component : SettingsComponent ) : Child () } } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Profile -> ProfileUi ( child . component ) is RootComponent . Child . Settings -> SettingsUi ( child . component ) } } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code } Animations \u00b6 Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function. Crossfade animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfade () ) { // Omitted code } } Crossfade-Scale animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfadeScale () ) { // Omitted code } } Slide animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = slide () ) { // Omitted code } } Custom animations \u00b6 It is possible to define custom animations in two ways. Implementing the ChildAnimation manually: @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { // Omitted code } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = { routerState : RouterState < C , T > , childContent : ChildContent < C , T > -> // Render each frame here } Implementing the ChildAnimation using the childAnimation builder function: fun < C : Any , T : Any > someAnimation ( animationSpec : FiniteAnimationSpec < Float > = defaultChildAnimationSpec , ): ChildAnimation < C , T > = childAnimation ( animationSpec = animationSpec ) { child : Child . Created < C , T > , factor : Float , placement : ChildPlacement , direction : ChildAnimationDirection , content : @Composable () -> Unit -> // Render the current frame here } Please refer to the predefined animations for implementation examples.","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#extensions-for-jetpackjetbrains-compose","text":"Extensions and utilities for easier integration of Decompose with Jetpack/JetBrains Compose.","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#setup","text":"Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant.","title":"Setup"},{"location":"extensions/compose/#setup-extensions-for-jetpack-compose","text":"Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" )","title":"Setup extensions for Jetpack Compose"},{"location":"extensions/compose/#setup-extensions-for-jetbrains-compose","text":"Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Setup extensions for JetBrains Compose"},{"location":"extensions/compose/#content","text":"As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module.","title":"Content"},{"location":"extensions/compose/#converting-value-to-state","text":"To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeUi ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () }","title":"Converting Value to State"},{"location":"extensions/compose/#navigating-between-composable-components","text":"The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided. Here is an example of switching child components on navigation: // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Profile ( val component : ProfileComponent ) : Child () data class Settings ( val component : SettingsComponent ) : Child () } } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Profile -> ProfileUi ( child . component ) is RootComponent . Child . Settings -> SettingsUi ( child . component ) } } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code }","title":"Navigating between Composable components"},{"location":"extensions/compose/#animations","text":"Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function.","title":"Animations"},{"location":"extensions/compose/#crossfade-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfade () ) { // Omitted code } }","title":"Crossfade animation"},{"location":"extensions/compose/#crossfade-scale-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfadeScale () ) { // Omitted code } }","title":"Crossfade-Scale animation"},{"location":"extensions/compose/#slide-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = slide () ) { // Omitted code } }","title":"Slide animation"},{"location":"extensions/compose/#custom-animations","text":"It is possible to define custom animations in two ways. Implementing the ChildAnimation manually: @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { // Omitted code } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = { routerState : RouterState < C , T > , childContent : ChildContent < C , T > -> // Render each frame here } Implementing the ChildAnimation using the childAnimation builder function: fun < C : Any , T : Any > someAnimation ( animationSpec : FiniteAnimationSpec < Float > = defaultChildAnimationSpec , ): ChildAnimation < C , T > = childAnimation ( animationSpec = animationSpec ) { child : Child . Created < C , T > , factor : Float , placement : ChildPlacement , direction : ChildAnimationDirection , content : @Composable () -> Unit -> // Render the current frame here } Please refer to the predefined animations for implementation examples.","title":"Custom animations"},{"location":"extensions/overview/","text":"Extensions Overview \u00b6 Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Overview"},{"location":"extensions/overview/#extensions-overview","text":"Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Extensions Overview"},{"location":"getting-started/contributing/","text":"Contributing \u00b6 Documentation \u00b6 All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Contributing"},{"location":"getting-started/contributing/#contributing","text":"","title":"Contributing"},{"location":"getting-started/contributing/#documentation","text":"All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Documentation"},{"location":"getting-started/installation/","text":"Decompose provides a number of modules, they all published to Maven Central Repository. The main Decompose module \u00b6 The main functionality is provided by the decompose module. It contains the core functionality, like Router , ComponentContext , etc. This module supports the following Kotlin Multiplatform targets: android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64 Gradle setup \u00b6 Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" ) Dependency on Essenty library \u00b6 Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like Lifecycle , StateKeeper , etc. Most important Essenty modules are added to the decompose module as api dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library. Extensions for Jetpack/JetBrains Compose \u00b6 The Compose UI is currently published in two separate variants: The one developed and maintained by Google is Android only, called Jetpack Compose The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, we call it JetBrains Compose Due to this fragmentation Decompose provides two separate extension modules for Compose UI: extensions-compose-jetpack - Android library for Jetpack Compose extensions-compose-jetbrains - Kotlin Multiplatform library for JetBrains Compose, supports android and jvm targets Both modules are used to connect Compose UI to Decompose components. Please see the corresponding documentation page . Gradle setup \u00b6 Typically only one module should be selected, depending on the Compose UI variant being used. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" // or implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) // or implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" ) Extensions for Android views \u00b6 The extensions-android module provides extensions to connect Android views based UI to Decompose components. Please head to the corresponding documentation page for more information. Gradle setup \u00b6 Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Installation"},{"location":"getting-started/installation/#the-main-decompose-module","text":"The main functionality is provided by the decompose module. It contains the core functionality, like Router , ComponentContext , etc. This module supports the following Kotlin Multiplatform targets: android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64","title":"The main Decompose module"},{"location":"getting-started/installation/#gradle-setup","text":"Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" )","title":"Gradle setup"},{"location":"getting-started/installation/#dependency-on-essenty-library","text":"Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like Lifecycle , StateKeeper , etc. Most important Essenty modules are added to the decompose module as api dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library.","title":"Dependency on Essenty library"},{"location":"getting-started/installation/#extensions-for-jetpackjetbrains-compose","text":"The Compose UI is currently published in two separate variants: The one developed and maintained by Google is Android only, called Jetpack Compose The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, we call it JetBrains Compose Due to this fragmentation Decompose provides two separate extension modules for Compose UI: extensions-compose-jetpack - Android library for Jetpack Compose extensions-compose-jetbrains - Kotlin Multiplatform library for JetBrains Compose, supports android and jvm targets Both modules are used to connect Compose UI to Decompose components. Please see the corresponding documentation page .","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"getting-started/installation/#gradle-setup_1","text":"Typically only one module should be selected, depending on the Compose UI variant being used. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" // or implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) // or implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Gradle setup"},{"location":"getting-started/installation/#extensions-for-android-views","text":"The extensions-android module provides extensions to connect Android views based UI to Decompose components. Please head to the corresponding documentation page for more information.","title":"Extensions for Android views"},{"location":"getting-started/installation/#gradle-setup_2","text":"Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Gradle setup"},{"location":"getting-started/license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"getting-started/samples/","text":"There are two sample apps: Counter and Todo List . Sample Counter App \u00b6 This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app watchOS sample app JavaScript sample app Counter Component Structure \u00b6 Sample Todo List App \u00b6 The sample Todo List App demonstrates the following features: Multiplatform: Android, iOS, Desktop and Web Shared JetBrains Compose UI for Android and Desktop apps JetBrains Compose UI for the Web browser app SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information. Todo Source Code \u00b6 The sample Todo List App can be found in the JetBrains Compose repository here . Sample Master-Detail App \u00b6 \u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, React for JS, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app JavaScript sample app Sample Dynamic Features App \u00b6 This sample demonstrates the following features: Play Feature Delivery for Android Static features for JVM (Desktop) Nested components Routing Multi-module structure API and implementation modules for dynamic features Pluggable UI (JetBrains Compose) \u26a0 For testing purposes all dynamic features are configured as install-time Content: shared/feature1Api - API module for dynamic Feature1 component shared/feature1Impl - implementation module for dynamic Feature1 component shared/feature2Api - API module for dynamic Feature2 component shared/feature2Impl - implementation module for dynamic Feature2 component shared/main - the Main component which is displayed at start shared/root - the Root component which navigates between the child components Android sample app Desktop sample app Sample Greetings App \u00b6 Sample Greetings Repository Related articles \u00b6 Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Samples"},{"location":"getting-started/samples/#sample-counter-app","text":"This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app watchOS sample app JavaScript sample app","title":"Sample Counter App"},{"location":"getting-started/samples/#counter-component-structure","text":"","title":"Counter Component Structure"},{"location":"getting-started/samples/#sample-todo-list-app","text":"The sample Todo List App demonstrates the following features: Multiplatform: Android, iOS, Desktop and Web Shared JetBrains Compose UI for Android and Desktop apps JetBrains Compose UI for the Web browser app SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information.","title":"Sample Todo List App"},{"location":"getting-started/samples/#todo-source-code","text":"The sample Todo List App can be found in the JetBrains Compose repository here .","title":"Todo Source Code"},{"location":"getting-started/samples/#sample-master-detail-app","text":"\u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, React for JS, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app JavaScript sample app","title":"Sample Master-Detail App"},{"location":"getting-started/samples/#sample-dynamic-features-app","text":"This sample demonstrates the following features: Play Feature Delivery for Android Static features for JVM (Desktop) Nested components Routing Multi-module structure API and implementation modules for dynamic features Pluggable UI (JetBrains Compose) \u26a0 For testing purposes all dynamic features are configured as install-time Content: shared/feature1Api - API module for dynamic Feature1 component shared/feature1Impl - implementation module for dynamic Feature1 component shared/feature2Api - API module for dynamic Feature2 component shared/feature2Impl - implementation module for dynamic Feature2 component shared/main - the Main component which is displayed at start shared/root - the Root component which navigates between the child components Android sample app Desktop sample app","title":"Sample Dynamic Features App"},{"location":"getting-started/samples/#sample-greetings-app","text":"Sample Greetings Repository","title":"Sample Greetings App"},{"location":"getting-started/samples/#related-articles","text":"Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Related articles"},{"location":"router/deeplinking/","text":"Deep linking \u00b6 Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android. Handling deep links \u00b6 Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = if ( initialItemId == null ) Config . List else Config . Details ( itemId = initialItemId ), initialBackStack = if ( initialItemId == null ) emptyList () else listOf ( Config . List ), handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the first screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Deep linking"},{"location":"router/deeplinking/#deep-linking","text":"Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android.","title":"Deep linking"},{"location":"router/deeplinking/#handling-deep-links","text":"Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = if ( initialItemId == null ) Config . List else Config . Details ( itemId = initialItemId ), initialBackStack = if ( initialItemId == null ) emptyList () else listOf ( Config . List ), handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the first screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Handling deep links"},{"location":"router/navigation/","text":"Navigation \u00b6 Router \u00b6 All navigation in Decompose is done through the Router interface. It has one function navigate(transformer: (List<C>) -> List<C>) which transforms the current stack of configurations into a new one by the provided transformer function. The stack is represented as List , where the last element is the top of the stack, and the first element is the bottom of the stack. \u26a0\ufe0f The returned stack must not be empty. The navigation is always performed synchronously during the navigate method call. The only exception to this rule is when the navigate method is called recursively. All recursive invocations are queued and performed one by one once the current navigation is finished. During the navigation process, the Router compares the new stack of configurations with the previous one. The Router ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed. Router extension functions \u00b6 There are Router extension functions that provide conveniences for navigating, some of which were already used in the router overview example . The preceding examples will utilize the following sealed class & router for showcasing the usage of the Router extensions. sealed class Configuration { object A : Configuration () object B : Configuration () object C : Configuration () object D : Configuration () } val router : Router < Configuration > Push \u00b6 Pushes the provided Configuration at the top of the stack. router . push ( Configuration . B ) router . push ( Configuration . C ) Pop \u00b6 Pops the latest configuration at the top of the stack. router . pop () Pop While \u00b6 Drops the configurations at the top of the stack while the provided predicate returns true. router . popWhile { topOfStack : Configuration -> topOfStack !is B } Replace Current \u00b6 Replaces the current configuration at the top of the stack with the provided Configuration . router . replaceCurrent ( Configuration . D ) Bring to Front \u00b6 Removes all components with configurations of the provided Configuration 's class, and adds the provided Configuration to the top of the stack. This is primarily helpful when implementing a Decompose app with bottom navigation Note The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated. router . bringToFront ( Configuration . B )","title":"Navigation"},{"location":"router/navigation/#navigation","text":"","title":"Navigation"},{"location":"router/navigation/#router","text":"All navigation in Decompose is done through the Router interface. It has one function navigate(transformer: (List<C>) -> List<C>) which transforms the current stack of configurations into a new one by the provided transformer function. The stack is represented as List , where the last element is the top of the stack, and the first element is the bottom of the stack. \u26a0\ufe0f The returned stack must not be empty. The navigation is always performed synchronously during the navigate method call. The only exception to this rule is when the navigate method is called recursively. All recursive invocations are queued and performed one by one once the current navigation is finished. During the navigation process, the Router compares the new stack of configurations with the previous one. The Router ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed.","title":"Router"},{"location":"router/navigation/#router-extension-functions","text":"There are Router extension functions that provide conveniences for navigating, some of which were already used in the router overview example . The preceding examples will utilize the following sealed class & router for showcasing the usage of the Router extensions. sealed class Configuration { object A : Configuration () object B : Configuration () object C : Configuration () object D : Configuration () } val router : Router < Configuration >","title":"Router extension functions"},{"location":"router/navigation/#push","text":"Pushes the provided Configuration at the top of the stack. router . push ( Configuration . B ) router . push ( Configuration . C )","title":"Push"},{"location":"router/navigation/#pop","text":"Pops the latest configuration at the top of the stack. router . pop ()","title":"Pop"},{"location":"router/navigation/#pop-while","text":"Drops the configurations at the top of the stack while the provided predicate returns true. router . popWhile { topOfStack : Configuration -> topOfStack !is B }","title":"Pop While"},{"location":"router/navigation/#replace-current","text":"Replaces the current configuration at the top of the stack with the provided Configuration . router . replaceCurrent ( Configuration . D )","title":"Replace Current"},{"location":"router/navigation/#bring-to-front","text":"Removes all components with configurations of the provided Configuration 's class, and adds the provided Configuration to the top of the stack. This is primarily helpful when implementing a Decompose app with bottom navigation Note The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated. router . bringToFront ( Configuration . B )","title":"Bring to Front"},{"location":"router/overview/","text":"Router Overview \u00b6 The Router \u00b6 A key unit is Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router . Component Configurations \u00b6 Each component created and managed by the Router has its Configuration . It is just a class with all the data required for the component instantiation. Configurations must meet the following requirements: Be immutable Correctly implement equals() and hashCode() methods Be unique (by equality) in the Router stack Implement Parcelable interface Configurations are the keys \u00b6 Each Configuration is a unique key of a component. The Router uses Configurations to check what components should be alive and what should be destroyed. On the client side, Configurations allow you to instantiate components with proper input parameters. For convenience and safety, you may define your Configurations as data class , and use only val properties and immutable data structures. Configurations are Parcelable \u00b6 Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose uses Essenty library, which provides both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. Please familiarise yourself with Essenty library. \u26a0\ufe0f On Android the amount of data that can be preserved is limited . Please take care of the Configuration sizes. Routing example \u00b6 Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , // Pop the back stack on back button press childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } } Multiple routers in a component \u00b6 When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Overview"},{"location":"router/overview/#router-overview","text":"","title":"Router Overview"},{"location":"router/overview/#the-router","text":"A key unit is Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router .","title":"The Router"},{"location":"router/overview/#component-configurations","text":"Each component created and managed by the Router has its Configuration . It is just a class with all the data required for the component instantiation. Configurations must meet the following requirements: Be immutable Correctly implement equals() and hashCode() methods Be unique (by equality) in the Router stack Implement Parcelable interface","title":"Component Configurations"},{"location":"router/overview/#configurations-are-the-keys","text":"Each Configuration is a unique key of a component. The Router uses Configurations to check what components should be alive and what should be destroyed. On the client side, Configurations allow you to instantiate components with proper input parameters. For convenience and safety, you may define your Configurations as data class , and use only val properties and immutable data structures.","title":"Configurations are the keys"},{"location":"router/overview/#configurations-are-parcelable","text":"Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose uses Essenty library, which provides both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. Please familiarise yourself with Essenty library. \u26a0\ufe0f On Android the amount of data that can be preserved is limited . Please take care of the Configuration sizes.","title":"Configurations are Parcelable"},{"location":"router/overview/#routing-example","text":"Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , // Pop the back stack on back button press childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } }","title":"Routing example"},{"location":"router/overview/#multiple-routers-in-a-component","text":"When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Multiple routers in a component"}]}